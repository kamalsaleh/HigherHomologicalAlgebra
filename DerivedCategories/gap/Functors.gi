# SPDX-License-Identifier: GPL-2.0-or-later
# DerivedCategories: Derived categories of Abelian categories
#
# Implementations
#
##
##  Functors
##
#############################################################################

##
InstallMethod( EquivalenceFromFullSubcategoryGeneratedByProjectiveObjectsIntoAdditiveClosureOfIndecProjectiveObjects,
          [ IsQuiverRepresentationCategory ],
  function( cat )
    local A, projs, indec_projs, add_indec_projs, r, name, F;
    
    A := AlgebraOfCategory( cat );
    
    projs := FullSubcategoryGeneratedByProjectiveObjects( cat );
    
    indec_projs := FullSubcategoryGeneratedByIndecProjectiveObjects( cat );
    
    add_indec_projs := AdditiveClosure( indec_projs  );
    
    DeactivateCachingOfCategory( add_indec_projs );
    
    name := "Equivalence functor from additive full subcategory generated by projective objects in additive closure";
    
    F := CapFunctor( name, projs, add_indec_projs );
    
    AddObjectFunction( F,
      function( a )
        local d;
        
        d := DecomposeProjectiveQuiverRepresentation( UnderlyingCell( a ) );
        
        if Size( d ) = 1 and IsZero( d[ 1 ] ) then
          
          d := ZeroObject( add_indec_projs );
          
          SetIsZeroForObjects( d, true );
          
          return d;
          
        fi;
        
        d := List( d, m -> AsSubcategoryCell( indec_projs, Source( m ) ) );
        
        return AdditiveClosureObject( d, add_indec_projs ); 
      
    end );
    
    
    AddMorphismFunction( F,
      function( s, alpha, r )
        local d_source_cell, d_range_cell, alpha_cell, iso, mat;
         
        if ( HasIsZeroForObjects( s ) and IsZeroForObjects( s ) ) or ( HasIsZeroForObjects( r ) and IsZeroForObjects( r ) ) then
          
          return ZeroMorphism( s, r );
          
        fi;
        
        d_source_cell := DecomposeProjectiveQuiverRepresentation( UnderlyingCell( Source( alpha ) ) );
        
        d_range_cell := DecomposeProjectiveQuiverRepresentation( UnderlyingCell( Range( alpha ) ) );
        
        alpha_cell := UnderlyingCell( alpha );
        
        iso := IsomorphismFromProjectiveRepresentationIntoCanonicalDecomposition( UnderlyingCell( Range( alpha ) ) );
        
        d_range_cell := List( d_range_cell, Source );
        
        d_range_cell := List( [ 1 .. Size( d_range_cell ) ],
          i -> PreCompose(
                  iso,
                  ProjectionInFactorOfDirectSumWithGivenDirectSum( d_range_cell, i, Range( iso ) )
                ) );
                
        mat := List( d_source_cell, u -> List( d_range_cell, v -> PreCompose( [ u, alpha_cell, v ] ) ) );
        
        mat := List( mat, row -> List( row, m -> AsSubcategoryCell( indec_projs, m ) ) );
        
        return AdditiveClosureMorphism( s, mat, r );
        
    end );
    
    return F;
    
end );

##
InstallMethod( EquivalenceFromAdditiveClosureOfIndecProjectiveObjectsIntoFullSubcategoryGeneratedByProjectiveObjects,
          [ IsQuiverRepresentationCategory ],
  function( cat )
    local indec_projs, projs, I;
    
    indec_projs := FullSubcategoryGeneratedByIndecProjectiveObjects( cat );
    
    projs := FullSubcategoryGeneratedByProjectiveObjects( cat );
    
    I := InclusionFunctor( indec_projs );
    
    I := RestrictFunctorToFullSubcategoryOfRange( I, projs );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    I!.Name := "Equivalence functor additive closure onto additive full subcategory generated by projective objects";
    
    return I;
    
end );

##
InstallMethod( EquivalenceFromFullSubcategoryGeneratedByInjectiveObjectsIntoAdditiveClosureOfIndecInjectiveObjects,
          [ IsQuiverRepresentationCategory ],
  function( cat )
    local A, injs, indec_injs, add_indec_injs, r, name, F;
    
    A := AlgebraOfCategory( cat );
    
    injs := FullSubcategoryGeneratedByInjectiveObjects( cat );
    
    indec_injs := FullSubcategoryGeneratedByIndecInjectiveObjects( cat );
    
    add_indec_injs := AdditiveClosure( indec_injs  );
    
    DeactivateCachingOfCategory( add_indec_injs );
    
    r := RandomBoldTextColor( );
    
    name := "Equivalence functor from additive full subcategory generated by injective objects in additive closure";
    
    F := CapFunctor( name, injs, add_indec_injs );
    
    AddObjectFunction( F,
      function( a )
        local d;
        
        d := DecomposeInjectiveQuiverRepresentation( UnderlyingCell( a ) );
        
        if Size( d ) = 1 and IsZero( d[ 1 ] ) then
          
          return ZeroObject( add_indec_injs );
          
        fi;
        
        d := List( d, m -> AsSubcategoryCell( indec_injs, Range( m ) ) );
        
        return AdditiveClosureObject( d, add_indec_injs ); 
        
    end );
    
    AddMorphismFunction( F,
      function( s, alpha, r )
        local d_source_cell, d_range_cell, alpha_cell, iso, mat;
        
        if ( HasIsZeroForObjects( s ) and IsZeroForObjects( s ) ) or ( HasIsZeroForObjects( r ) and IsZeroForObjects( r ) ) then
          
          return ZeroMorphism( s, r );
          
        fi;
        
        d_source_cell := DecomposeInjectiveQuiverRepresentation( UnderlyingCell( Source( alpha ) ) );
        
        d_range_cell := DecomposeInjectiveQuiverRepresentation( UnderlyingCell( Range( alpha ) ) );
        
        alpha_cell := UnderlyingCell( alpha );
        
        iso := IsomorphismOntoInjectiveRepresentationFromCanonicalDecomposition( UnderlyingCell( Source( alpha ) ) );
        
        d_source_cell := List( d_source_cell, Range );
        
        d_source_cell := List( [ 1 .. Size( d_source_cell ) ],
          i -> PostCompose(
                  iso,
                  InjectionOfCofactorOfDirectSumWithGivenDirectSum( d_source_cell, i, Source( iso ) )
                ) );
                
        mat := List( d_source_cell, u -> List( d_range_cell, v -> PreCompose( [ u, alpha_cell, v ] ) ) );
        
        mat := List( mat, row -> List( row, m -> AsSubcategoryCell( indec_injs, m ) ) );
        
        return AdditiveClosureMorphism( s, mat, r );
        
    end );
    
    return F;
  
end );

##
InstallMethod( EquivalenceFromAdditiveClosureOfIndecInjectiveObjectsIntoFullSubcategoryGeneratedByInjectiveObjects,
          [ IsQuiverRepresentationCategory ],
  function( cat )
    local indec_injs, injs, I;
    
    indec_injs := FullSubcategoryGeneratedByIndecInjectiveObjects( cat );
    
    injs := FullSubcategoryGeneratedByInjectiveObjects( cat );
    
    I := InclusionFunctor( indec_injs );
    
    I := RestrictFunctorToFullSubcategoryOfRange( I, injs );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    I!.Name := "Equivalence functor additive closure onto additive full subcategory generated by injective objects";
    
    return I;
    
end );

##
InstallMethod( IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra,
          [ IsAlgebroid ],
  function( algebroid )
    local A, A_op, full, ambient_cat, quiver_op, nr_vertices, basis, projs, projs_in_subcategory, r, name, F;
    
    A := UnderlyingQuiverAlgebra( algebroid );
    
    A_op := OppositeAlgebra( A );
    
    full := FullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
    
    ambient_cat := AmbientCategory( full );
    
    quiver_op := QuiverOfAlgebra( A_op );
    
    nr_vertices := NumberOfVertices( quiver_op );
    
    basis := BasisOfProjectives( A_op );
    
    projs := IndecProjRepresentations( A_op );
    
    r := RandomBoldTextColor( );
    
    name := "Isomorphism functor from algebroid onto full subcategory generated by indecomposable projective objects";
    
    F := CapFunctor( name, algebroid, full );
    
    AddObjectFunction( F,
      function( a )
        local i, aa, p;
        
        i := VertexIndex( UnderlyingVertex( a ) );
        
        aa := basis[ PositionProperty( basis, b -> [ A_op.( String( Vertex( quiver_op, i ) ) ) ] in b ) ];
        
        p := projs[ PositionProperty( projs, p -> DimensionVector( p ) = List( aa, Size ) ) ];
        
        return AsSubcategoryCell( full, p );
        
      end );
      
    AddMorphismFunction( F,
      function( s, alpha, r )
        local e, mor;
        
        e := UnderlyingQuiverAlgebraElement( alpha );
        
        e := OppositeAlgebraElement( e );
        
        mor := MorphismBetweenIndecProjectivesGivenByElement( 
                UnderlyingCell( s ),
                e,
                UnderlyingCell( r ) );
                
        return AsSubcategoryCell( full, mor );
        
      end );
      
    return F;
    
end );

##
InstallMethod( IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra,
          [ IsStrongExceptionalCollection ],
  function( collection )
    local full, iso_1, algebroid, iso_2, iso, ind_projs, r, name, cell_func;
    
    full := DefiningFullSubcategory( collection );
    
    iso_1 := IsomorphismOntoAlgebroid( collection );
    
    algebroid := RangeOfFunctor( iso_1 );
    
    iso_2 := IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
    
    iso := PreCompose( iso_1, iso_2 );
    
    ind_projs := RangeOfFunctor( iso );
    
    name := "Isomorphism functor from exceptional collection in full subcategory generated by indecomposable projective objects";
    
    cell_func := c -> ApplyFunctor( iso, c );
    
    return FunctorFromLinearCategoryByTwoFunctions( name, full, ind_projs, cell_func, cell_func );
end );

##
InstallMethod( IsomorphismFromFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra,
          [ IsStrongExceptionalCollection ],
  function( collection )
    local full, iso_1, algebroid, iso_2, iso, ind_projs, r, name, cell_func;
    
    full := DefiningFullSubcategory( collection );
    
    iso_1 := IsomorphismFromAlgebroid( collection );
    
    algebroid := SourceOfFunctor( iso_1 );
    
    iso_2 := IsomorphismFromFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
    
    iso := PostCompose( iso_1, iso_2 );
    
    ind_projs := SourceOfFunctor( iso );
    
    name := "Isomorphism functor from full subcategory generated by indecomposable projective objects onto exceptional collection";
    
    cell_func := c -> ApplyFunctor( iso, c );
    
    return FunctorFromLinearCategoryByTwoFunctions( name, ind_projs, full, cell_func, cell_func );
    
end );

##
InstallMethod( IsomorphismFromFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra,
          [ IsAlgebroid ],
  function( algebroid )
    local A, A_op, full, quiver_op, nr_vertices, basis, projs, r, name, object_func, morphism_func;
    
    A := UnderlyingQuiverAlgebra( algebroid );
    
    A_op := OppositeAlgebra( A );
    
    full := FullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
    
    quiver_op := QuiverOfAlgebra( A_op );
    
    nr_vertices := NumberOfVertices( quiver_op );
    
    basis := BasisOfProjectives( A_op );
    
    projs := IndecProjRepresentations( A_op );
    
    name := "Isomorphism functor from full subcategory generated by indecomposable projective objects onto algebroid";
    
    object_func :=
      function( a )
        local p, i;
        
        p := UnderlyingCell( a );
        
        p := basis[ PositionProperty( basis, b -> DimensionVector( p ) = List( b, Size ) ) ];
        
        i := PositionProperty( [ 1 .. nr_vertices ], i -> [ A_op.( String( Vertex( quiver_op, i ) ) ) ] in p );
        
        return ObjectInAlgebroid( algebroid, Vertex( QuiverOfAlgebra( A ), i ) );
        
      end;
      
    morphism_func :=
      function( alpha )
        local s, r, basis, I, images, dim, rel;
        
        s := object_func( Source( alpha ) );
        
        r := object_func( Range( alpha ) );
        
        basis := BasisOfExternalHom( s, r );
        
        I := IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( algebroid );
        
        images := List( basis, b -> ApplyFunctor( I, b ) );
        
        dim := Size( basis );
        
        rel := RelationsBetweenMorphisms( Concatenation( [ alpha ], images ) );
        
        if Size( rel ) > 1 then
        
          Error( "This should not happen!\n" );
          
        fi;
        
        rel := AdditiveInverse( Inverse( rel[ 1 ][ 1 ] ) ) * rel[ 1 ];
        
        rel := rel{ [ 2 .. dim + 1 ] };
        
        if IsEmpty( rel ) then
          
          return ZeroMorphism( s, r );
          
        else
          
          return rel * basis;
          
        fi;
        
      end;
      
    return FunctorFromLinearCategoryByTwoFunctions( name, full, algebroid, object_func, morphism_func );
    
end );

##
InstallMethod( IsomorphismOntoAlgebroid,
        [ IsStrongExceptionalCollection ],
  function( collection )
    local n, full, A, algebroid, r, name, object_func, morphism_func, conv, algebroid_ring;
    
    n := NumberOfObjects( collection );
    
    full := DefiningFullSubcategory( collection );
    
    A := EndomorphismAlgebra( collection );
    
    algebroid := Algebroid( A );
    
    algebroid_ring := CommutativeRingOfLinearCategory( algebroid );
    
    if not IsIdenticalObj( CommutativeRingOfLinearCategory( full ), algebroid_ring ) then
      
      conv := a -> a / algebroid_ring;
      
    else
      
      conv := IdFunc;
      
    fi;
    
    name := "Isomorphism functor from exceptional collection onto algebroid";
    
    object_func :=
      function( e )
        local p;
        
        p := PositionProperty( [ 1 .. n ], i -> IsEqualForObjects( e, collection[ i ] ) );
        
        return SetOfObjects( algebroid )[ p ];
        
    end;
    
    morphism_func :=
      function( phi )
        local s, source, i, r, range, j, basis, labels, dim, paths, rel, v;
        
        s := Source( phi );
        
        source := object_func( s );
        
        i := PositionProperty( [ 1 .. n ], k -> IsEqualForObjects( s, collection[ k ] ) );
        
        r := Range( phi );
        
        range := object_func( r );
        
        j := PositionProperty( [ 1 .. n ], k -> IsEqualForObjects( r, collection[ k ] ) );
        
        basis := BasisOfPaths( collection, i, j );
        
        v := collection!.char;
        
        if IsEmpty( basis ) then
          
          return ZeroMorphism( source, range );
          
        fi;
        
        labels := LabelsForBasisOfPaths( collection, [ i, j ] );
        
        dim := Length( basis );
        
        if i > j then
          
          return ZeroMorphism( source, range );
          
        elif i = j then
          
          paths := [ IdentityMorphism( algebroid.( i ) ) ]; # Because the quiver has no loops.
          
        else
          
          paths :=
            List( labels, label ->
              PreCompose(
                List( label, arrow_label ->
                  algebroid.(
                    Concatenation(
                       v,
                       String( arrow_label[ 1 ] ),
                       "_",
                       String( arrow_label[ 2 ] ),
                       "_",
                       String( arrow_label[ 3 ] ) )
                            )
                )
              )
            );
        fi;
        
        rel := RelationsBetweenMorphisms( Concatenation( [ phi ], basis ) );
        
        if Length( rel ) > 1 then
          
          Error( "This should not happen, please report this" );
          
        fi;
        
        rel := AdditiveInverse( Inverse( rel[ 1 ][ 1 ] ) ) * rel[ 1 ];
        
        return List( rel{ [ 2 .. dim + 1 ] }, conv ) * paths;
        
    end;
    
    return FunctorFromLinearCategoryByTwoFunctions( name, full, algebroid, object_func, morphism_func );
    
end );


##
functor :=
  [
    IsCapFullSubcategory,
    IsAlgebroid,
    function( full, oid )
      local collection;
      if not HasStrongExceptionalCollection( full ) then
        return false;
      fi;
      collection := StrongExceptionalCollection( full );
      if not HasAlgebroid( collection ) then
        return false;
      fi;
      if not IsIdenticalObj( oid, Algebroid( collection ) ) then
        return false;
      fi;
      return true;
    end,
    { full, oid } -> IsomorphismOntoAlgebroid( StrongExceptionalCollection( full ) ),
    "Isomorphism functor from an exceptional collection onto the associated algebroid"
  ];

AddFunctor( functor );
ExtendFunctorMethodToAdditiveClosureAndComplexCategories( functor );
ExtendFunctorMethodToAdditiveClosureAndHomotopyCategories( functor );


##
InstallMethod( IsomorphismFromAlgebroid,
        [ IsStrongExceptionalCollection ],
  function( collection )
    local n, full, A, algebroid, r, name, object_func, morphism_func;
    
    n := NumberOfObjects( collection );
    
    full := DefiningFullSubcategory( collection );
    
    A := EndomorphismAlgebra( collection );
    
    algebroid := Algebroid( A );
    
    name := "Isomorphism functor from algebroid onto exceptional collection";
    
    object_func :=
      function( e )
        local p;
        
        p := VertexIndex( UnderlyingVertex( e ) );
        
        return collection[ p ];
        
    end;
    
    morphism_func :=
      function( phi )
        local source, range, s, i, r, j, e, paths, coeffs, arrow_list, paths_list;
        
        source := object_func( Source( phi ) );
        
        range := object_func( Range( phi ) );
        
        s := Source( phi );
        
        i := VertexIndex( UnderlyingVertex( s ) );
        
        r := Range( phi );
        
        j := VertexIndex( UnderlyingVertex( r ) );
        
        e := Representative( UnderlyingQuiverAlgebraElement( phi ) );
        
        if IsZero( e ) then
          
          return ZeroMorphism( source, range );
          
        fi;
        
        paths := Paths( e );
        
        coeffs := Coefficients( e );
        
        if Size( paths ) = 1 and Source( paths[ 1 ] ) = Target( paths[ 1 ] ) then
          
          return coeffs * [ IdentityMorphism( source ) ];
          
        fi;
        
        arrow_list := List( paths, ArrowList );
        
        arrow_list := List( arrow_list,
          l -> List( l, arrow -> [
                                    VertexIndex( Source( arrow ) ),
                                    VertexIndex( Target( arrow ) ),
                                    Int( SplitString( Label( arrow ), "_" )[ 3 ] )
                                 ]
                    ) );
                    
        paths_list := List( arrow_list,
          l -> PreCompose(
                   List( l, indices -> Arrows( collection, indices[ 1 ], indices[ 2 ] )[ indices[ 3 ] ] )
                    ) );
                    
        return coeffs * paths_list;
        
    end;
    
    return FunctorFromLinearCategoryByTwoFunctions( name, algebroid, full, object_func, morphism_func );
    
end );

##
functor :=
  [
    IsAlgebroid,
    IsCapFullSubcategory,
    function( oid, full )
      local collection;
      if not HasStrongExceptionalCollection( full ) then
        return false;
      fi;
      collection := StrongExceptionalCollection( full );
      if not HasAlgebroid( collection ) then
        return false;
      fi;
      if not IsIdenticalObj( oid, Algebroid( collection ) ) then
        return false;
      fi;
      return true;
    end,
    { oid, full } -> IsomorphismFromAlgebroid( StrongExceptionalCollection( full ) ),
    "Isomorphism functor from algebroid associated to an exceptional collection onto the exceptional collection"
  ];

AddFunctor( functor );
ExtendFunctorMethodToAdditiveClosureAndComplexCategories( functor );
ExtendFunctorMethodToAdditiveClosureAndHomotopyCategories( functor );

##
InstallMethod( LocalizationFunctor,
              [ IsHomotopyCategory ],
  function( homotopy )
    local complexes, cat, D, r, name, F;
    
    complexes := UnderlyingCategory( homotopy );
    
    cat := UnderlyingCategory( complexes );
    
    if IsChainComplexCategory( complexes ) then
      
      D := DerivedCategory( cat, false );
      
    else
      
      D := DerivedCategory( cat, true );
      
    fi;
    
    name := "Localization functor in derived category";
    
    F := CapFunctor( name, homotopy, D );
    
    AddObjectFunction( F, a -> a / D );
    
    AddMorphismFunction( F, { s, alpha, r } -> alpha / D );
    
    return F;
    
end );

##
InstallMethod( UniversalFunctorFromDerivedCategory,
          [ IsCapFunctor ],
  function( F )
    local homotopy_cat, C, cat, D, r, name, U;
    
    homotopy_cat := SourceOfFunctor( F );
    
    C := RangeOfFunctor( F );
    
    if not IsHomotopyCategory( homotopy_cat ) then
      
      Error( "The input be a functor from homotopy category of some abelian category" );
      
    fi;
    
    cat := DefiningCategory( homotopy_cat );
    
    D := DerivedCategory( cat );
    
    name := "Universal functor from derived category onto a localization category";
    
    U := CapFunctor( name, D, C );
    
    AddObjectFunction( U,
      function( a )
        
        return ApplyFunctor( F, UnderlyingCell( a ) );
        
    end );
    
    AddMorphismFunction( U,
      function( s, alpha, r )
        local i, j;
        
        i := ApplyFunctor( F, SourceMorphism( UnderlyingRoof( alpha ) ) );
        
        j := ApplyFunctor( F, RangeMorphism( UnderlyingRoof( alpha ) ) );
        
        return PreCompose( Inverse( i ), j );
        
    end );
    
    return U;
    
end );

##
InstallMethod( LDerivedFunctor,
          [ IsCapFunctor ],
  function( F )
    local H_1, cat_1, D_1, H_2, cat_2, D_2, name, LF, r;
    
    H_1 := SourceOfFunctor( F );
    
    H_2 := RangeOfFunctor( F );
    
    if not ( IsHomotopyCategory( H_1 ) and IsHomotopyCategory( H_2 ) ) then
      
      TryNextMethod( );
      
    fi;
    
    cat_1 := DefiningCategory( H_1 );
    
    D_1 := DerivedCategory( cat_1 );
    
    cat_2 := DefiningCategory( H_2 );
    
    D_2 := DerivedCategory( cat_2 );
    
    if not IsAbelianCategoryWithComputableEnoughProjectives( cat_1 ) then
      
      Error( Name( cat_1 ), " should be abelian with enough projectives!\n" );
      
    fi;
    
    name := "Left derived functor";
    
    LF := CapFunctor( name, D_1, D_2 );
    
    AddObjectFunction( LF,
      function( a )
        local p;
        
        p := ProjectiveResolution( UnderlyingCell( UnderlyingCell( a ) ), true ) / H_1;
        
        return ApplyFunctor( F, p ) / D_2;
        
    end );
    
    AddMorphismFunction( LF,
      function( s, alpha, r )
        local roof, quasi_iso, morphism, F_quasi_iso, F_morphism;
        
        roof := UnderlyingRoof( alpha );
        
        quasi_iso := SourceMorphism( roof );
        
        quasi_iso := MorphismBetweenProjectiveResolutions( UnderlyingCell( quasi_iso ), true ) / H_1;
        
        morphism := RangeMorphism( roof );
        
        morphism := MorphismBetweenProjectiveResolutions( UnderlyingCell( morphism ), true ) / H_1;
        
        F_quasi_iso := ApplyFunctor( F, quasi_iso );
        
        F_morphism := ApplyFunctor( F, morphism );
        
        roof := Roof( F_quasi_iso, F_morphism );
        
        return DerivedCategoryMorphism( s, roof, r );
        
    end );
    
    return LF;
    
end );

##
InstallMethod( LDerivedFunctor,
          [ IsCapFunctor ],
  function( F )
    local cat_1;
    
    cat_1 := SourceOfFunctor( F );
    
    if not ( HasIsAbelianCategory( cat_1 )
                and IsAbelianCategory( cat_1 )
                  and IsAbelianCategoryWithComputableEnoughProjectives( cat_1 ) ) then
                  
      TryNextMethod( );
      
    fi;
    
    return LDerivedFunctor( ExtendFunctorToHomotopyCategories( F ) );
    
end );

InstallMethod( LeftDerivedFunctor, [ IsCapFunctor ], LDerivedFunctor );

##
InstallMethod( RDerivedFunctor,
          [ IsCapFunctor ],
  function( F )
    local H_1, cat_1, D_1, H_2, cat_2, D_2, name, RF, r;
    
    H_1 := SourceOfFunctor( F );
    
    H_2 := RangeOfFunctor( F );
    
    if not ( IsHomotopyCategory( H_1 ) and IsHomotopyCategory( H_2 ) ) then
      
      TryNextMethod( );
      
    fi;
    
    cat_1 := DefiningCategory( H_1 );
    
    D_1 := DerivedCategory( cat_1 );
    
    cat_2 := DefiningCategory( H_2 );
    
    D_2 := DerivedCategory( cat_2 );
    
    if not IsAbelianCategoryWithComputableEnoughInjectives( cat_1 ) then
      
      Error( Name( cat_1 ), " should be abelian with enough injectives!\n" );
      
    fi;
    
    name := "Right derived functor";
    
    RF := CapFunctor( name, D_1, D_2 );
    
    AddObjectFunction( RF,
      function( a )
        local i;
        
        i := InjectiveResolution( UnderlyingCell( UnderlyingCell( a ) ), true ) / H_1;
        
        return ApplyFunctor( F, i ) / D_2;
        
    end );
    
    AddMorphismFunction( RF,
      function( s, alpha, r )
        local roof, quasi_iso, morphism, F_quasi_iso, F_morphism;
        
        roof := UnderlyingRoof( alpha );
        
        quasi_iso := SourceMorphism( roof );
        
        quasi_iso := MorphismBetweenInjectiveResolutions( UnderlyingCell( quasi_iso ), true ) / H_1;
        
        morphism := RangeMorphism( roof );
        
        morphism := MorphismBetweenInjectiveResolutions( UnderlyingCell( morphism ), true ) / H_1;
        
        F_quasi_iso := ApplyFunctor( F, quasi_iso );
        
        F_morphism := ApplyFunctor( F, morphism );
        
        roof := Roof( F_quasi_iso, F_morphism );
        
        return DerivedCategoryMorphism( s, roof, r );
        
    end );
    
    return RF;
    
end );

##
InstallMethod( RDerivedFunctor,
          [ IsCapFunctor ],
  function( F )
    local cat_1;
    
    cat_1 := SourceOfFunctor( F );
    
    if not ( HasIsAbelianCategory( cat_1 )
                and IsAbelianCategory( cat_1 )
                  and IsAbelianCategoryWithComputableEnoughInjectives( cat_1 ) ) then
                  
      TryNextMethod( );
      
    fi;
    
    return RDerivedFunctor( ExtendFunctorToHomotopyCategories( F ) );
    
end );

##
InstallMethod( RightDerivedFunctor, [ IsCapFunctor ], RDerivedFunctor );

########################################
#
# Convolution functor
#
########################################

##
InstallMethod( EquivalenceFromAdditiveClosure,
          [ IsCapFullSubcategory ],
  function( full )
    local I, add_closure_full;
    
    I := InclusionFunctor( full );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    add_closure_full := AdditiveClosureAsFullSubcategory( full );
    
    I := RestrictFunctorToFullSubcategoryOfRange( I, add_closure_full );
    
    I!.Name := "Isomorphism functor from formal additive closure onto additive colsure as full subcategory";
    
    return I;
    
end );

##
InstallMethod( EquivalenceFromAdditiveClosure,
          [ IsStrongExceptionalCollection ],
  collection -> EquivalenceFromAdditiveClosure( DefiningFullSubcategory( collection ) )
);

##
InstallMethod( EquivalenceFromHomotopyCategory,
          [ IsStrongExceptionalCollection ],
  collection -> ExtendFunctorToHomotopyCategories( EquivalenceFromAdditiveClosure( collection ) )
);

##
InstallMethod( EmbeddingFunctorFromAdditiveClosure,
          [ IsCapFullSubcategory ],
  function( full )
    local I, add_closure_full;
    
    I := InclusionFunctor( full );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    I!.Name := "Embedding functor from formal additive closure into the ambient category";
    
    return I;
    
end );

##
InstallMethod( EmbeddingFunctorFromAdditiveClosure,
          [ IsStrongExceptionalCollection ],
  collection -> EmbeddingFunctorFromAdditiveClosure( DefiningFullSubcategory( collection ) )
);

##
InstallMethod( EmbeddingFunctorFromHomotopyCategory,
          [ IsStrongExceptionalCollection ],
  function( collection )
    local iota, ambient_cat, complexes_cat;
    
    iota := EmbeddingFunctorFromAdditiveClosure( collection );
    
    ambient_cat := AmbientCategory( collection );
    
    complexes_cat := UnderlyingCategory( ambient_cat );
    
    if IsCochainComplexCategory( complexes_cat ) then
      
      return ExtendFunctorToHomotopyCategories( iota, true );
      
    elif IsChainComplexCategory( complexes_cat ) then
      
      return ExtendFunctorToHomotopyCategories( iota, false );
      
    else
      
      Error( "The ambient category of the collection should be a homotopy category!\n" );
      
    fi;
    
end );

##
BindGlobal( "SET_COMMUTATIVITY_NAT_ISO_BETWEEN_REPLACEMENT_AND_SHIFT",
  function( collection, rep )
    local D, sigma_D, C, sigma_C, rep_o_sigma_C, sigma_D_o_rep, name, eta;
    
    D := HomotopyCategory( collection );
    
    sigma_D := ShiftFunctor( D );
    
    C := AmbientCategory( collection );
    
    sigma_C := ShiftFunctor( C );
    
    rep_o_sigma_C := PostCompose( rep, sigma_C );
    
    sigma_D_o_rep := PostCompose( sigma_D, rep );
    
    name := "Natural isomorphism G o Σ => Σ o G";
    
    eta := NaturalTransformation( name, rep_o_sigma_C, sigma_D_o_rep );
    
    AddNaturalTransformationFunction( eta,
      function( rep_o_sigma_a, a, sigma_D_o_rep_a )
        local z_func;
        
        z_func := AsZFunction( i -> ( -1 ) ^ ( i - 1 ) * IdentityMorphism( rep_o_sigma_a[ i ] ) );
        
        return HomotopyCategoryMorphism( rep_o_sigma_a, sigma_D_o_rep_a, z_func );
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( rep, eta );
   
end );

##
InstallMethod( ReplacementFunctor,
          [ IsStrongExceptionalCollection ],
  function( collection )
    local ambient_cat, homotopy_cat, name, Rep;
    
    ambient_cat := AmbientCategory( collection );
    
    homotopy_cat := HomotopyCategory( collection );
    
    name := "Replacement functor";
    
    Rep := CapFunctor( name, ambient_cat, homotopy_cat );
    
    AddObjectFunction( Rep,
      a -> ExceptionalReplacement( a, collection, true )
    );
    
    AddMorphismFunction( Rep,
      { s, alpha, r } -> ExceptionalReplacement( alpha, collection, true )
    );
    
    SET_COMMUTATIVITY_NAT_ISO_BETWEEN_REPLACEMENT_AND_SHIFT( collection, Rep );
    
    return Rep;
    
end );

##
InstallMethod( ReplacementFunctorIntoHomotopyCategoryOfAdditiveClosureOfAlgebroid,
          [ IsStrongExceptionalCollection ],
  function( collection )
    local ambient_cat, complexes_cat, J, eta_J, G, eta_G, GJ, sigma_S, sigma_T, GJ_o_sigma_S, sigma_T_o_GJ, eta;
    
    ambient_cat := AmbientCategory( collection );
    
    complexes_cat := UnderlyingCategory( ambient_cat );
    
    J := IsomorphismOntoAlgebroid( collection );
    
    J := ExtendFunctorToAdditiveClosureOfSource( J );
    
    if IsChainComplexCategory( complexes_cat ) then
      
      J := ExtendFunctorToHomotopyCategories( J, false );
      
    else
      
      J := ExtendFunctorToHomotopyCategories( J, true );
      
    fi;
    
    eta_J := CommutativityNaturalTransformationWithShiftFunctor( J );
    
    G := ReplacementFunctor( collection );
    
    eta_G := CommutativityNaturalTransformationWithShiftFunctor( G );
    
    GJ := PreCompose( G, J );
    
    sigma_S := ShiftFunctor( SourceOfFunctor( GJ ) );
    
    sigma_T := ShiftFunctor( RangeOfFunctor( GJ ) );
    
    GJ_o_sigma_S := PostCompose( GJ, sigma_S );
    
    sigma_T_o_GJ := PostCompose( sigma_T, GJ );
    
    eta := NaturalTransformation( "Natural isomorphism G o Σ => Σ o G", GJ_o_sigma_S, sigma_T_o_GJ );
    
    AddNaturalTransformationFunction( eta,
      function( GJ_o_sigma_S_a, a, sigma_T_o_GJ_a )
        
        return PreCompose(
                  ApplyFunctor( J, ApplyNaturalTransformation( eta_G, a ) ),
                  ApplyNaturalTransformation( eta_J, ApplyFunctor( G, a ) )
                );
                
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( GJ, eta );
    
    GJ!.Name := "Replacement functor";
    
    return GJ;
    
end );

##
InstallMethod( ReplacementFunctorIntoHomotopyCategoryOfQuiverRows,
          [ IsStrongExceptionalCollection ],
  function( collection )
    local ambient_cat, complexes_cat, C, J, eta_J, G, eta_G, GJ, sigma_S, sigma_T, GJ_o_sigma_S, sigma_T_o_GJ, eta;
    
    ambient_cat := AmbientCategory( collection );
    
    complexes_cat := UnderlyingCategory( ambient_cat );
    
    C := Algebroid( collection );
    
    C := AdditiveClosure( C );
    
    J := IsomorphismOntoQuiverRows( C );
    
    if IsChainComplexCategory( complexes_cat ) then
      
      J := ExtendFunctorToHomotopyCategories( J, false );
      
    else
      
      J := ExtendFunctorToHomotopyCategories( J, true );
      
    fi;
    
    eta_J := CommutativityNaturalTransformationWithShiftFunctor( J );
    
    G := ReplacementFunctorIntoHomotopyCategoryOfAdditiveClosureOfAlgebroid( collection );
    
    eta_G := CommutativityNaturalTransformationWithShiftFunctor( G );

    GJ := PreCompose( G, J );
    
    sigma_S := ShiftFunctor( SourceOfFunctor( GJ ) );
    
    sigma_T := ShiftFunctor( RangeOfFunctor( GJ ) );
    
    GJ_o_sigma_S := PostCompose( GJ, sigma_S );
    
    sigma_T_o_GJ := PostCompose( sigma_T, GJ );
    
    eta := NaturalTransformation( "Natural isomorphism G o Σ => Σ o G", GJ_o_sigma_S, sigma_T_o_GJ );
    
    AddNaturalTransformationFunction( eta,
      function( GJ_o_sigma_S_a, a, sigma_T_o_GJ_a )
        
        return PreCompose(
                  ApplyFunctor( J, ApplyNaturalTransformation( eta_G, a ) ),
                  ApplyNaturalTransformation( eta_J, ApplyFunctor( G, a ) )
                );
                
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( GJ, eta );
    
    GJ!.Name := "Replacement functor";
    
    return GJ;
   
end );

BindGlobal( "SET_COMMUTATIVITY_NAT_ISO_BETWEEN_CONVOLUTION_AND_SHIFT",
  function( collection, conv )
    local D, sigma_D, C, sigma_C, conv_o_sigma_D, sigma_C_o_conv, name, eta;
    
    C := AmbientCategory( collection );
    
    D := HomotopyCategory( collection );
    
    sigma_D := ShiftFunctor( D );
     
    sigma_C := ShiftFunctor( C );
    
    conv_o_sigma_D := PostCompose( conv, sigma_D );
    
    sigma_C_o_conv := PostCompose( sigma_C, conv );
    
    name := "Natural isomorphism F o Σ => Σ o F";
    
    eta := NaturalTransformation( name, conv_o_sigma_D, sigma_C_o_conv );
    
    AddNaturalTransformationFunction( eta,
      function( conv_o_sigma_D_a, a, sigma_C_o_conv_a )
        local diffs, b, z_func, alpha;
        
        diffs := Differentials( a );
        
        diffs := ApplyMap( diffs, AdditiveInverse );
        
        b := HomotopyCategoryObject( D, diffs );
        
        SetLowerBound( b, ActiveLowerBound( a ) );
        
        SetUpperBound( b, ActiveUpperBound( a ) );
        
        z_func := AsZFunction( i -> ( -1 ) ^ i * IdentityMorphism( a[ i ] ) );
        
        alpha := HomotopyCategoryMorphism( a, b, z_func );
        
        alpha := conv_o_sigma_D( alpha );
                
        return alpha;
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( conv, eta );
   
end );

##
InstallMethod( ConvolutionFunctor,
          [ IsStrongExceptionalCollection ],
  function( collection )
    local ambient_cat, complexes_cat, homotopy_cat, conv;
     
    ambient_cat := AmbientCategory( collection );
    
    complexes_cat := UnderlyingCategory( ambient_cat );
    
    if IsCochainComplexCategory( complexes_cat ) or IsChainComplexCategory( complexes_cat ) then
      
      homotopy_cat := HomotopyCategory( collection );
      
    else
      
      Error( "The ambient category of the collection should be a homotopy category!\n" );
      
    fi;

    conv := CapFunctor( "Convolution functor", homotopy_cat, ambient_cat );
    
    AddObjectFunction( conv, BackwardConvolution );
    
    AddMorphismFunction( conv, { s, alpha, r } -> BackwardConvolution( alpha ) );
    
    SET_COMMUTATIVITY_NAT_ISO_BETWEEN_CONVOLUTION_AND_SHIFT( collection, conv );
    
    return conv;
    
end );

##
InstallMethod( ConvolutionFunctorFromHomotopyCategoryOfAdditiveClosureOfAlgebroid,
    [ IsStrongExceptionalCollection ],
  function( collection )
    local ambient_cat, complexes_cat, I, eta_I, F, eta_F, IF, sigma_S, sigma_T, IF_o_sigma_S, sigma_T_o_IF, eta;
    
    ambient_cat := AmbientCategory( collection );
    
    complexes_cat := UnderlyingCategory( ambient_cat );
    
    I := IsomorphismFromAlgebroid( collection );
    
    I := ExtendFunctorToAdditiveClosureOfSource( I );
    
    if IsChainComplexCategory( complexes_cat ) then
      
      I := ExtendFunctorToHomotopyCategories( I, false );
      
    else
      
      I := ExtendFunctorToHomotopyCategories( I, true );
      
    fi;
    
    eta_I := CommutativityNaturalTransformationWithShiftFunctor( I );
    
    F := ConvolutionFunctor( collection );
    
    eta_F := CommutativityNaturalTransformationWithShiftFunctor( F );
    
    IF := PreCompose( I, F );
    
    sigma_S := ShiftFunctor( SourceOfFunctor( IF ) );

    sigma_T := ShiftFunctor( RangeOfFunctor( IF ) );

    IF_o_sigma_S := PostCompose( IF, sigma_S );

    sigma_T_o_IF := PostCompose( sigma_T, IF );

    eta := NaturalTransformation( "Natural isomorphism F o Σ => Σ o F", IF_o_sigma_S, sigma_T_o_IF );
    
    AddNaturalTransformationFunction( eta,
      function( IF_o_sigma_S_a, a, sigma_T_o_IF_a )
      
        return PreCompose(
                  ApplyFunctor( F, ApplyNaturalTransformation( eta_I, a ) ),
                  ApplyNaturalTransformation( eta_F, ApplyFunctor( I, a ) )
                );
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( IF, eta );
    
    IF!.Name := "Convolution functor";
    
    return IF;
    
end );

##
InstallMethod( ConvolutionFunctorFromHomotopyCategoryOfQuiverRows,
    [ IsStrongExceptionalCollection ],
  function( collection )
    local ambient_cat, complexes_cat, oid, oid_plus, I, eta_I, F, eta_F, IF, sigma_S, sigma_T, IF_o_sigma_S, sigma_T_o_IF, eta;
    
    ambient_cat := AmbientCategory( collection );
    
    complexes_cat := UnderlyingCategory( ambient_cat );
   
    oid := Algebroid( collection );
    
    oid_plus := AdditiveClosure( oid );
    
    I := IsomorphismFromQuiverRows( oid_plus );
    
    if IsChainComplexCategory( complexes_cat ) then
      
      I := ExtendFunctorToHomotopyCategories( I, false );
      
    else
      
      I := ExtendFunctorToHomotopyCategories( I, true );
      
    fi;
     
    eta_I := CommutativityNaturalTransformationWithShiftFunctor( I );
    
    F := ConvolutionFunctorFromHomotopyCategoryOfAdditiveClosureOfAlgebroid( collection );
    
    eta_F := CommutativityNaturalTransformationWithShiftFunctor( F );
    
    IF := PreCompose( I, F );
    
    sigma_S := ShiftFunctor( SourceOfFunctor( IF ) );

    sigma_T := ShiftFunctor( RangeOfFunctor( IF ) );

    IF_o_sigma_S := PostCompose( IF, sigma_S );

    sigma_T_o_IF := PostCompose( sigma_T, IF );

    eta := NaturalTransformation( "Natural isomorphism F o Σ => Σ o F", IF_o_sigma_S, sigma_T_o_IF );
    
    AddNaturalTransformationFunction( eta,
      function( IF_o_sigma_S_a, a, sigma_T_o_IF_a )
      
        return PreCompose(
                  ApplyFunctor( F, ApplyNaturalTransformation( eta_I, a ) ),
                  ApplyNaturalTransformation( eta_F, ApplyFunctor( I, a ) )
                );
        
    end );
    
    SetCommutativityNaturalTransformationWithShiftFunctor( IF, eta );
    
    IF!.Name := "Convolution functor";
    
    return IF;
    
end );

##
AddFunctor(
    IsHomotopyCategory,
    IsHomotopyCategory,
    { category_1, category_2 }
          -> IsAdditiveClosureCategory( DefiningCategory( category_1 ) ) and
              IsAdditiveClosureCategory( DefiningCategory( category_2 ) ) and
                HasStrongExceptionalCollection( UnderlyingCategory( DefiningCategory( category_1 ) ) ) and
                  IsIdenticalObj( category_2, AmbientCategory( StrongExceptionalCollection( UnderlyingCategory( DefiningCategory( category_1 ) ) ) ) ),
    function( category_1, category_2 )
      local collection;
      
      collection := StrongExceptionalCollection( UnderlyingCategory( DefiningCategory( category_1 ) ) );
      
      return ConvolutionFunctor( collection );
      
    end,
    "The convolution functor"
);
     
##
AddFunctor(
    IsHomotopyCategory,
    IsHomotopyCategory,
    { category_2, category_1 }
          -> IsAdditiveClosureCategory( DefiningCategory( category_1 ) ) and
              IsAdditiveClosureCategory( DefiningCategory( category_2 ) ) and
                HasStrongExceptionalCollection( UnderlyingCategory( DefiningCategory( category_1 ) ) ) and
                  IsIdenticalObj( category_2, AmbientCategory( StrongExceptionalCollection( UnderlyingCategory( DefiningCategory( category_1 ) ) ) ) ),
    function( category_2, category_1 )
      local collection;
      
      collection := StrongExceptionalCollection( UnderlyingCategory( DefiningCategory( category_1 ) ) );
      
      return ReplacementFunctor( collection );
      
    end,
    "The exceptional replacement functor"
);

####################################
#
# Inverse of isomorphism functors
# Between k-linear categories with
# homomorphism structure
#
####################################

##
InstallMethod( ImageOfFunctor,
          [ IsCapFunctor ],
  function( I )
    local C, R, images_obj_C, r, name, full;
    
    C := SourceOfFunctor( I );
    
    R := RangeOfFunctor( I );
    
    if IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( C ) then
      
      images_obj_C := List( SetOfKnownObjects( C ), I );
      
    elif IsAlgebroid( C ) then
      
      images_obj_C := List( SetOfObjects( C ), I );
      
    else
      
      TryNextMethod( );
      
    fi;
    
    r := RandomTextColor( Name( R ) );
    
    name := Concatenation( r[ 1 ], "Full subcategory( ", r[ 2 ], Name( R ), r[ 1 ],
        " ) generated by values of a functor on ", String( Size( images_obj_C ) ), " objects", r[ 2 ] );
        
    full := FullSubcategoryGeneratedByListOfObjects( images_obj_C : name_of_full_subcategory := name );
    
    SetDefiningFunctor( full, I );
    
    return full;
    
end );

##
InstallMethod( ImageOfFullyFaithfullFunctor,
          [ IsCapFunctor ],
  function( I )
    local R, image, r, name;
    
    R := RangeOfFunctor( I );
    
    r := RandomTextColor( Name( R ) );
        
    image := ImageOfFunctor( I );
    
    SetDefiningFullyFaithfulFunctor( image, I );
    
    name := Concatenation( r[ 1 ], "Full subcategory( ", r[ 2 ], Name( R ), r[ 1 ],
        " ) generated by values of a fully faithfull functor on ", String( Size( SetOfKnownObjects( image ) ) ), " objects", r[ 2 ] );

    
    image!.Name := name;
    
    return image;
    
end );

##
InstallMethod( IsomorphismOntoImageOfFullyFaithfulFunctor,
          [ IsCapFunctor ],
  function( I )
    local C, D, r, name;
    
    C := SourceOfFunctor( I );
    
    if not ( IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( C )
              or IsAlgebroid( C ) ) then
      
      TryNextMethod( );
      
    fi;
    
    D := ImageOfFullyFaithfullFunctor( I );
    
    r := RandomTextColor( Name( I ) );
    
    name := Concatenation( r[ 1 ], "Isomorphism functor onto the image ( ", r[ 2 ],
              Name( I ), r[ 1 ], " ) ", r[ 2 ]
              );
              
    I := RestrictFunctorToFullSubcategoryOfRange( I, D );
    
    I!.Name := name;
    
    return I;
    
end );

##
InstallMethod( IsomorphismFromImageOfFullyFaithfulFunctor,
          [ IsCapFunctor ],
  function( I )
    local C, D, object_func, images_of_morphisms_D, morphism_func, r, name, ring, coeffs;
    
    C := SourceOfFunctor( I );
     
    if not ( IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( C )
              or IsAlgebroid( C ) ) then
      
      TryNextMethod( );
      
    fi;
    
    D := ImageOfFullyFaithfullFunctor( I );
    
    if IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( C ) then
      
      object_func := o -> SetOfKnownObjects( C )[ Position( SetOfKnownObjects( D ), o ) ];
      
    else
      
      object_func := o -> SetOfObjects( C )[ Position( SetOfKnownObjects( D ), o ) ];
      
    fi;
    
    ring := CommutativeRingOfLinearCategory( C );
    
    images_of_morphisms_D := [ [ ], [ ] ];
    
    morphism_func :=
      function( alpha )
        local a, b, pre_a, pre_b, p, B_pre_a_pre_b, B_a_b, morphism_1, I_B_pre_a_pre_b, morphism_2, lift, coeffs;
        
        a := Source( alpha );
        
        b := Range( alpha );
        
        B_a_b := BasisOfExternalHom( a, b );
        
        pre_a := object_func( a );
        
        pre_b := object_func( b );
        
        p := Position( images_of_morphisms_D[ 1 ], [ a, b ] );
        
        if p = fail then
          
          B_pre_a_pre_b := BasisOfExternalHom( pre_a, pre_b );
          
          morphism_1 := InterpretListOfMorphismsAsOneMorphismInRangeCategoryOfHomomorphismStructure( a, b, B_a_b );
          
          I_B_pre_a_pre_b := List( B_pre_a_pre_b, m -> I( m ) / D );
          
          morphism_2 := InterpretListOfMorphismsAsOneMorphismInRangeCategoryOfHomomorphismStructure( a, b, I_B_pre_a_pre_b );
          
          lift := Lift( morphism_1, morphism_2 );
          
          coeffs := EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( lift ) * ring );
          
          Add( images_of_morphisms_D[ 1 ], [ a, b ] );
          
          Add( images_of_morphisms_D[ 2 ], List( coeffs, c -> c * B_pre_a_pre_b ) );
          
          p := Size( images_of_morphisms_D[ 1 ] );
          
        fi;
        
        coeffs := CoefficientsOfMorphismWithGivenBasisOfExternalHom( alpha, B_a_b );
        
        return List( coeffs, c -> c / ring ) * images_of_morphisms_D[ 2 ][ p ];
        
    end;
    
    r := RandomTextColor( Name( I ) );
    
    name := Concatenation( r[ 1 ], "Isomorphism functor from the image ( ", r[ 2 ],
              Name( I ), r[ 1 ], " ) ", r[ 2 ]
              );
              
    return FunctorFromLinearCategoryByTwoFunctions( name, D, C, object_func, morphism_func );
    
end );

###################################
#
# Embedding in derived category
#
###################################

##
InstallMethod( EmbeddingFunctorFromAmbientCategoryIntoDerivedCategory,
          [ IsStrongExceptionalCollection ],
  collection -> EmbeddingFunctorIntoDerivedCategory( AmbientCategory( collection ) )
);

##
InstallMethod( EmbeddingFunctorIntoDerivedCategory,
          [ IsCapCategory ],
  function( C )
    local Ho_C, I, J, F, D, A, U, CP, N, objs, collection, full, name, k, algebroid, add_algebroid;
    
    if HasIsAbelianCategory( C ) and IsAbelianCategory( C ) then
      
      Ho_C := HomotopyCategory( C );
      
      I := EmbeddingFunctorInHomotopyCategory( C );
      J := LocalizationFunctor( Ho_C );
      
      F := PreCompose( I, J );
      
      F!.Name := "Embedding functor of an abelian category in its derived category";
      
      return F;
      
    elif IsHomotopyCategory( C ) then
      
      D := DefiningCategory( C );
      
      if IsCapFullSubcategory( D ) then
        
        if HasIsAdditiveCategory( D ) and IsAdditiveCategory( D ) then
          
          A := AmbientCategory( D );
          
          if HasIsAbelianCategory( A ) and IsAbelianCategory( A ) then
            
            I := InclusionFunctor( D );
            
            I := ExtendFunctorToHomotopyCategories( I );
            
            J := LocalizationFunctor( RangeOfFunctor( I ) );
            
            F := PreCompose( I, J );
            
            F!.Name := "Equivalence functor from homotopy category onto derived category";
            
            return F;
            
          else
            
            return fail;
            
          fi;
          
        else
          
          return fail;
          
        fi;
        
      elif IsAdditiveClosureCategory( D ) then
        
        U := UnderlyingCategory( D );
        
        if IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects( U ) then
          
          A := AmbientCategory( U );
          
          if HasIsAbelianCategory( A ) and IsAbelianCategory( A ) then
            
            I := ExtendFunctorToAdditiveClosureOfSource( InclusionFunctor( U ) );
            
            I := ExtendFunctorToHomotopyCategories( I );
            
            J := LocalizationFunctor( RangeOfFunctor( I ) );
            
            F := PreCompose( I, J );
            
            F!.Name := "Equivalence functor from homotopy category onto derived category";
            
            return F;
            
          else
            
            return fail;
            
          fi;
        
        elif IsAlgebroid( U ) then
          
          I := IsomorphismOntoFullSubcategoryGeneratedByIndecProjRepresentationsOverOppositeAlgebra( U );
          
          I := PreCompose( I, InclusionFunctor( RangeOfFunctor( I ) ) );
          
          I := ExtendFunctorToAdditiveClosureOfSource( I );
          
          I := ExtendFunctorToHomotopyCategories( I );
          
          J := LocalizationFunctor( RangeOfFunctor( I ) );
          
          F := PreCompose( I, J );
          
          F!.Name := "Equivalence functor from homotopy category onto derived category";
          
          return F;
        
        elif IsLinearClosure( U ) and IsProSetAsCategory( UnderlyingCategory( U ) ) then
          
          CP := UnderlyingCategory( U );
          
          N := Size( IncidenceMatrix( CP )[ 1 ] );
          
          objs := List( [ 1 .. N ], i -> LinearClosureObject( U, i/CP ) );
          
          collection := CreateStrongExceptionalCollection( objs );
          
          full := DefiningFullSubcategory( collection );
          
          name := "Isomorphism functor from ProSetAsCategory onto full subcategory generated by all its objects" ;
          
          I := CapFunctor( name, U, full );
          
          AddObjectFunction( I, a -> a / full );
          
          AddMorphismFunction( I, { s, alpha, r } -> alpha / full );
          
          I := PreCompose( I, IsomorphismOntoAlgebroid( collection ) );
          
          I := ExtendFunctorToAdditiveClosures( I );
          
          I := ExtendFunctorToHomotopyCategories( I );
          
          J := EmbeddingFunctorIntoDerivedCategory( RangeOfFunctor( I ) );
          
          return PreCompose( I, J );
          
        else
          
          return fail;
          
        fi;
        
      elif IsQuiverRowsCategory( D ) then
        
        A := UnderlyingQuiverAlgebra( D );
        
        k := CommutativeRingOfLinearCategory( D );
        
        if ( HasIsIntegersForHomalg( k ) and IsIntegersForHomalg( k ) ) or IsIntegers( k ) then
          
          algebroid := Algebroid( A, true );
          
        else
          
          algebroid := Algebroid( A );
          
        fi;
        
        add_algebroid := AdditiveClosure( algebroid );
        
        I := IsomorphismFromQuiverRowsIntoAdditiveClosureOfAlgebroid( D, add_algebroid );
        
        I := ExtendFunctorToHomotopyCategories( I );
        
        F := EmbeddingFunctorIntoDerivedCategory( HomotopyCategory( add_algebroid ) );
        
        F := PreCompose( I, F );
        
        F!.Name := "Equivalence functor from homotopy category onto derived category";
        
        return F;
        
      else
        
        return fail;
        
      fi;
      
    elif IsDerivedCategory( C ) then
      
      return IdentityFunctor( C );
      
    else
      
      return fail;
      
    fi;
    
end );

##
InstallMethod( EquivalenceFromGradedLeftPresentationsOntoFreydCategoryOfGradedRows,
          [ IsHomalgGradedRing ],
  function( S )
    local fpres, rows, freyd, name, F;
    
    fpres := GradedLeftPresentations( S );
    
    rows := CategoryOfGradedRows( S );
    
    freyd := FreydCategory( rows );
    
    name := "Equivalence functor from graded left presentations onto Freyd category of graded rows";
    
    F := CapFunctor( name, fpres, freyd );

    AddObjectFunction( F,
      function( o )
        local degrees, range, m;
        
        degrees := GeneratorDegrees( o );
        
        degrees := List( degrees, d -> [ -d, 1 ] );
        
        range := GradedRow( degrees, S );
        
        m := UnderlyingMatrix( o );
        
        m := DeduceSomeMapFromMatrixAndRangeForGradedRows( m, range );
        
        return FreydCategoryObject( m );
        
    end );
    
    AddMorphismFunction( F,
      function( s, alpha, r )
        
        alpha := GradedRowOrColumnMorphism(
                    Range( RelationMorphism( s ) ),
                    UnderlyingMatrix( alpha ),
                    Range( RelationMorphism( r ) )
                  );
                  
        return FreydCategoryMorphism( s, alpha, r );

    end );
    
    return F;
    
end );

##
InstallMethod( EquivalenceFromFreydCategoryOfGradedRowsOntoGradedLeftPresentations,
          [ IsHomalgGradedRing ],
  function( S )
    local fpres, rows, freyd, name, F;
    
    fpres := GradedLeftPresentations( S );
    
    rows := CategoryOfGradedRows( S );
    
    freyd := FreydCategory( rows );
    
    name := "Equivalence functor from Freyd category of graded rows onto graded left presentations";
    
    F := CapFunctor( name, freyd, fpres );
    
    AddObjectFunction( F,
      function( o )
        local rm, degrees;
        
        rm := RelationMorphism( o );
        
        degrees := DegreeList( Range( rm ) );
        
        degrees := Concatenation( List( degrees, d -> ListWithIdenticalEntries( d[ 2 ], -d[ 1 ] ) ) );
        
        return AsGradedLeftPresentation( UnderlyingHomalgMatrix( rm ), degrees );
        
    end );
    
    AddMorphismFunction( F,
      function( s, alpha, r )
        
        alpha := MorphismDatum( alpha );
    
        return GradedPresentationMorphism( s, UnderlyingHomalgMatrix( alpha ), r );
        
    end );
    
    return F;
    
end );

######################################
#
# F_1 : algebroid_1 -> full subcategory 1
# F_2 : algebroid_2 -> full subcategory 2
#
######################################

##
InstallMethodWithCrispCache( IsomorphismFromTensorProductOfAlgebroidsOntoBoxProductOfFullSubcategories,
          [ IsCapFunctor, IsCapFunctor, IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects ],
  function( F_1, F_2, box_product_full_subcategory )
    local ring, algebroid_1, A_1, algebroid_2, A_2, algebroid, func_on_object, func_on_morphism, name;
    
    ring := CommutativeRingOfLinearCategory( box_product_full_subcategory );
    
    algebroid_1 := SourceOfFunctor( F_1 );
    
    algebroid_2 := SourceOfFunctor( F_2 );
    
    if not ( IsAlgebroid( algebroid_1 ) and IsAlgebroid( algebroid_2 ) ) then
      Error( "Wrong input!\n" );
    fi;
    
    A_1 := UnderlyingQuiverAlgebra( algebroid_1 );
    
    A_2 := UnderlyingQuiverAlgebra( algebroid_2 );
    
    algebroid := TensorProductOnObjects( algebroid_1, algebroid_2 );
    
    func_on_object :=
      function( o )
        local factors;
        
        factors := ProductPathFactors( UnderlyingVertex( o ) );
        
        return BoxProduct(
                  ApplyFunctor( F_1, factors[ 1 ] / algebroid_1 ),
                  ApplyFunctor( F_2, factors[ 2 ] / algebroid_2 ),
                  box_product_full_subcategory
                );
      end;
    
    func_on_morphism :=
      function( alpha )
        local dec, L, p, i, j;
      
        dec := DecompositionOfMorphismInAlgebroid( alpha );
        
        if IsEmpty( dec ) then
          return ZeroMorphism( func_on_object( Source( alpha ) ), func_on_object( Range( alpha ) ) );
        fi;
        
        L := [ ];
        
        for i in [ 1 .. Size( dec ) ] do
          
          L[ i ] := [ dec[ i ][ 1 ] / ring, [ ] ];
          
          for j in [ 1 .. Size( dec[ i ][ 2 ] ) ] do
            
            p := Paths( Representative( UnderlyingQuiverAlgebraElement( dec[ i ][ 2 ][ j ] ) ) );
            
            if not Size( p ) = 1 then
              Error( "This should not happen!\n" );
            fi;
            
            p := p[ 1 ];
            
            p := ListN( [ algebroid_1, algebroid_2 ], [ A_1, A_2 ], ProductPathFactors( p ),
                    { algebroid, algebra, a } -> algebra.( String( a ) ) / algebroid
                  );
             
            L[ i ][ 2 ][ j ] :=
               BoxProduct(
                    ApplyFunctor( F_1, p[ 1 ] ),
                    ApplyFunctor( F_2, p[ 2 ] ),
                    box_product_full_subcategory
                  );
                  
          od;
            
        od;
        
        return Sum( List( L, l -> MultiplyWithElementOfCommutativeRingForMorphisms( l[ 1 ], PreCompose( l[ 2 ] ) ) ) );
        
      end;
      
    name := "Evaluation functor from tensor product of algebroids onto full subcategory defined by a box product";
    
    return FunctorFromLinearCategoryByTwoFunctions( name, algebroid, box_product_full_subcategory, func_on_object, func_on_morphism );
      
end );

##
InstallOtherMethod( IsomorphismFromTensorProductOfAlgebroidsOntoBoxProductOfFullSubcategories,
      [ IsCapFunctor, IsCapFunctor, IsStrongExceptionalCollection ],
  { F_1, F_2, collection } -> IsomorphismFromTensorProductOfAlgebroidsOntoBoxProductOfFullSubcategories( F_1, F_2, DefiningFullSubcategory( collection ) )
);

##
InstallMethodWithCrispCache( IsomorphismFromBoxProductOfFullSubcategoriesOntoTensorProductOfAlgebroids,
          [ IsCapFunctor, IsCapFunctor, IsCapFullSubcategoryGeneratedByFiniteNumberOfObjects ],
  function( F_1, F_2, box_product_full_subcategory )
    local V, name, F;
    
    V := IsomorphismFromTensorProductOfAlgebroidsOntoBoxProductOfFullSubcategories( F_1, F_2, box_product_full_subcategory );
    
    V := IsomorphismFromImageOfFullyFaithfulFunctor( V );
    
    name := "Abstraction functor from full subcategory defined by a box product onto tensor product of algebroids";
    
    F := CapFunctor( name, AmbientCategory( SourceOfFunctor( V ) ), RangeOfFunctor( V ) );
    
    AddObjectFunction( F,
      o -> ApplyFunctor( V,  o / SourceOfFunctor( V ) )
    );
    
    AddMorphismFunction( F,
      { s, alpha, r } -> ApplyFunctor( V,  alpha / SourceOfFunctor( V ) )
    );
    
    return F;
    
end );

##
InstallOtherMethod( IsomorphismFromBoxProductOfFullSubcategoriesOntoTensorProductOfAlgebroids,
      [ IsCapFunctor, IsCapFunctor, IsStrongExceptionalCollection ],
  { F_1, F_2, collection } -> IsomorphismFromBoxProductOfFullSubcategoriesOntoTensorProductOfAlgebroids( F_1, F_2, DefiningFullSubcategory( collection ) )
);

